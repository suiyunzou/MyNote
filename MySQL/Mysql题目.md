## **<font style="color:#DF2A3F;">Mysql是如何执行一条语句的？</font>**
**回答要点：连接器 、缓存、解析SQL、执行SQL；**

<details class="lake-collapse"><summary id="ud4d4546c"><span class="ne-text">参考</span></summary><ul class="ne-ul"><li id="u8ed89f8a" data-lake-index-type="0"><strong><span class="ne-text" style="color: #262626">连接器：TCP协议连接，验证用户权限；</span></strong></li><li id="ue166ed91" data-lake-index-type="0"><strong><span class="ne-text" style="color: #262626">缓存：为什么使用缓存？</span></strong></li><li id="u4b95a99b" data-lake-index-type="0"><strong><span class="ne-text" style="color: #262626">解析SQL： 1.词法分析 ；2.语法分析；3.构建语法树；</span></strong></li><li id="u93d01b5e" data-lake-index-type="0"><strong><span class="ne-text" style="color: #262626">执行SQL：1.预处理器；2.优化器； 3.创建执行计划；4.执行器；</span></strong></li></ul><p id="u1627e721" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1723601068837-f9a80f75-d009-4db5-ae9b-f6196787bc79.png" width="469" id="bpAzp" class="ne-image"></p><p id="ua544c91f" class="ne-p"><br></p></details>




## **<font style="color:#DF2A3F;">如何存储一行记录？</font>**
**<font style="color:#000000;">回答要点：InnoDB的行格式 、Compact 行格式具体有什么及重点6部分作用；</font>**

<details class="lake-collapse"><summary id="ua3688582"><span class="ne-text">参考</span></summary><ul class="ne-ul"><li id="u27b0500b" data-lake-index-type="0"><span class="ne-text">InnoDB行格式：Redundant、Compact、Dynamic、Compressed；</span></li><li id="u56fc8a56" data-lake-index-type="0"><span class="ne-text">Compact：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ue6214c98" data-lake-index-type="0"><span class="ne-text">变长字段长度列表：从左至右扫描一行数据，如果发现是</span><strong><span class="ne-text">变长字段</span></strong><span class="ne-text">，依次记录它的实际长度，并逆序记录在变长字段长度列表中。 对于ascii，一个长度是一个字节。当长度&lt;=255时候，用一个字节表示；当长度&gt;255时候用两个字节表示；</span></li><li id="u43551abe" data-lake-index-type="0"><span class="ne-text">NULL值列表：：从左至右扫描一行数据，如果发现该字段可为空，就用1bit位上的一位表示；并记录为1，当不能为空时，用0记录（当超过8个字段都为空时，用2个字节表示），并逆序存放；当表的全部字段都不为空时，NULL值列表删除；</span></li><li id="ub64fd3cf" data-lake-index-type="0"><span class="ne-text">row_id：当表已经存在【主键或不为空的唯一约束】时，将自动会删除；当表不存在时将会自动创建；</span></li><li id="ue05f83bf" data-lake-index-type="0"><span class="ne-text">trx_ID：事务ID；</span></li><li id="u1ab3cc7a" data-lake-index-type="0"><span class="ne-text">roll_ptr：回滚指针；</span></li><li id="uf34987aa" data-lake-index-type="0"><span class="ne-text">列值表：记录真实数据，可有多列；</span></li></ul></ul><p id="uc16399d7" class="ne-p"><br></p><p id="u6cce70d7" class="ne-p"><span class="ne-text">扩展：</span></p><ul class="ne-ul"><li id="u3ca9506f" data-lake-index-type="0"><span class="ne-text">了解行、页、区、段的概念；</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u1edbb46f" data-lake-index-type="0"><span class="ne-text">行：Mysql表中的一行数据；</span></li><li id="uda671e60" data-lake-index-type="0"><span class="ne-text">页：InnoDB的最小读取单位；每页16KB =16*1024=16384byte；</span></li><li id="u42b90527" data-lake-index-type="0"><span class="ne-text">区：当InnoDB每次读取的数据量过大时，将以区为单位读取数据；</span></li><li id="ub6c779e3" data-lake-index-type="0"><span class="ne-text">段：数据段；索引段；回滚段；</span></li></ul></ul><ul class="ne-ul"><li id="u87faaf8f" data-lake-index-type="0"><span class="ne-text">varchar(n)中n最大值？</span></li></ul><p id="u94889130" class="ne-p"><span class="ne-text">    65536-变长字段长度-NULL值列表；</span></p><p id="u5bdaf6f0" class="ne-p"><br></p></details>
**<font style="color:#DF2A3F;">  
</font>**

## **<font style="color:#DF2A3F;">索引的分类？</font>**
**<font style="color:#000000;">回答要点：4大类型；按数据结构、物理结构、字段个数、字段特性；</font>**

<details class="lake-collapse"><summary id="u46e691db"><span class="ne-text">参考</span></summary><ul class="ne-ul"><li id="uac724745" data-lake-index-type="0"><span class="ne-text">按数据结构：B+树索引、Hash索引、Full_Text索引？；</span></li><li id="u409b9737" data-lake-index-type="0"><span class="ne-text">按物理结构：聚簇索引(主键索引)，二级索引(非聚簇索引 | 辅助索引)；</span></li><li id="u6889547a" data-lake-index-type="0"><span class="ne-text">按字段类型：主键索引、唯一索引、前缀索引、普通索引；</span></li><li id="ue948fb92" data-lake-index-type="0"><span class="ne-text">按字段个数：单列索引、联合索引；</span></li></ul><p id="u41f555d0" class="ne-p"><span class="ne-text">扩展：<br /></span><strong><span class="ne-text">主键索引</span></strong><span class="ne-text">(图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行)：<br /></span><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1723605601458-798010df-3076-4711-b739-becd68927adb.png" width="811.2" id="ufb0f47e4" class="ne-image"></p><p id="u9a3fda25" class="ne-p"><strong><span class="ne-text">二级索引</span></strong><span class="ne-text">(图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行)：<br /></span><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1723605672276-45116513-a97b-4555-9643-e05624ce8cac.png" width="805.6" id="QD8rq" class="ne-image"></p><p id="u6dc5797f" class="ne-p"><strong><span class="ne-text">回表（</span></strong><span class="ne-text">图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）：<br /></span><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1723605757157-17c8fbf8-f8fd-440c-8a91-3e2c98ce2dd8.png" width="1264.8" id="u2acc9e95" class="ne-image"></p><p id="u9acbcba3" class="ne-p"><br></p></details>
**<font style="color:#DF2A3F;"></font>**

## <font style="color:#DF2A3F;">什么是索引下推？</font>
**回答要点：先将找满足条件的数据，再去回表；**

比如：

索引下推：where a>1 and b=2；先找a>1的第一条数据，然后从叶子节点中a>1的范围中找到符合b=2的数据；然后再去回表查询数据；

非索引下推：a>1范围内的每条数据都回表查询，判断是否b=2；

<details class="lake-collapse"><summary id="u843aaaee"><span class="ne-text">参考：</span></summary><p id="u14d42fbb" class="ne-p"><span class="ne-text"></span></p><p id="u8198fe73" class="ne-p"><span class="ne-text">举例：假设有一个&quot;员工&quot;表,包含字段:id, 姓名, 年龄, 部门。我们在&quot;姓名&quot;和&quot;年龄&quot;上建立了联合索引。</span></p><p id="u5be377cb" class="ne-p"><span class="ne-text">现在有一个查询:</span></p><pre data-language="plain" id="nHW89" class="ne-codeblock language-plain"><code>
SELECT * FROM 员工 WHERE 姓名 LIKE 'Zhang%' AND 年龄 &gt; 30;</code></pre><p id="u7a9b9f12" class="ne-p"><span class="ne-text">没有索引下推时,MySQL会:</span></p><ol class="ne-ol"><li id="u8585d946" data-lake-index-type="0"><span class="ne-text">使用索引找到所有姓&quot;Zhang&quot;的员工</span></li><li id="u126ac10f" data-lake-index-type="0"><span class="ne-text">取出这些员工的完整记录</span></li><li id="u32b71fb1" data-lake-index-type="0"><span class="ne-text">再筛选出年龄大于30的</span></li></ol><p id="u40c1622c" class="ne-p"><span class="ne-text">有了索引下推后,MySQL可以:</span></p><ol class="ne-ol"><li id="u5a3c5b9e" data-lake-index-type="0"><span class="ne-text">在索引中找到姓&quot;Zhang&quot;的员工</span></li><li id="u254c44a5" data-lake-index-type="0"><span class="ne-text">直接在索引中筛选年龄大于30的</span></li><li id="u3f78d08d" data-lake-index-type="0"><span class="ne-text">只取出符合两个条件的员工记录</span></li></ol></details>




## <font style="color:#DF2A3F;">什么是最左匹配原则？</font>
**回答要点：联合索引+与索引顺序一致+从左至右**

<details class="lake-collapse"><summary id="uf978db70"><span class="ne-text">参考</span></summary><ul class="ne-ul"><li id="u0913b251" data-lake-index-type="0"><span class="ne-text">最左匹配原则发生在二级索引的联合索引中；</span></li></ul><p id="u83b7b4bb" class="ne-p"><span class="ne-text">联合索引：将表中主键和其他几个字段共同创建一个索引；比如：(a,b,c)三个字段组成联合索引；</span></p><ul class="ne-ul"><li id="u7bfde8aa" data-lake-index-type="0"><span class="ne-text">最左匹配原则需满足： where a=1 and b=2 and c=3；a，b，c分别与联合索引一一对应；顺序可以不同，因为优化器会优化sql语句；</span></li><li id="u38a56a25" data-lake-index-type="0"><span class="ne-text">最左匹配什么时候会停止？</span></li></ul><p id="ue98d147c" class="ne-p"><span class="ne-text">当a   遇到 &gt; 、 &lt; 会停止匹配； 遇到&gt;=、&lt;=、between 、like继续匹配。</span></p><p id="u681d29ce" class="ne-p"><span class="ne-text"></span></p></details>


## <font style="color:#DF2A3F;">什么时候需要创建索引？</font>
**回答要点：优缺点+用/不用；**

<details class="lake-collapse"><summary id="u48c720ca"><span class="ne-text">参考</span></summary><p id="u1be2ccdc" class="ne-p"><span class="ne-text">优点：提高查询效率；<br /></span><span class="ne-text">缺点：需要占用额外的存储空间；创建和维护索引需要耗费额外时间；降低增删改的效率；</span></p><p id="ub45af351" class="ne-p"><span class="ne-text">用   ： 字段有唯一性限制；经常用where查询的字段；常用于group by order by的字段；</span></p><p id="u00622ed4" class="ne-p"><span class="ne-text">不用：where / order by / group by 用不到的字段；存储大量重复数据(性别)；直接全表扫描；表中数据少；经常更新的字段；</span></p></details>


## <font style="color:#DF2A3F;">如何进行索引优化？</font>
**回答要点：创建表时的设置+写查询语句的注意点+创建索引的注意点**

<details class="lake-collapse"><summary id="uae4ef4cf"><span class="ne-text">参考</span></summary><p id="u779818f2" class="ne-p"><span class="ne-text">创建表时：</span></p><p id="u2e391749" class="ne-p"><span class="ne-text">主键要设置为自增：自增主键是追加操作；非主键是插入操作，会产生页分裂；</span></p><p id="u0b2ad1c3" class="ne-p"><span class="ne-text">索引设置为NOT NULL：为空时会增加记录的存储空间；导致索引统计、比较 困难；</span></p><p id="u427d8575" class="ne-p"><span class="ne-text"></span></p><p id="u5b80af34" class="ne-p"><span class="ne-text">写SQL语句时：</span></p><p id="ue7fd53ff" class="ne-p"><span class="ne-text">条件查询避免：like%XX，%XXX%；联合索引要遵循最左匹配；where查询条件中 使用or时，不要使用索引列 or 非索引列；</span></p><p id="ubf0124fa" class="ne-p"><span class="ne-text"></span></p><p id="uf0c1f0dd" class="ne-p"><span class="ne-text">创建索引时：</span></p><p id="u575725e4" class="ne-p"><span class="ne-text">前缀索引优化：使用字符串的前几位进行创建索引，减少索引长度；</span></p><p id="ue915abd8" class="ne-p"><span class="ne-text">覆盖索引优化：经常查询片段使用二级索引中的覆盖索引，减少回表；</span></p><p id="uff8cd82a" class="ne-p"><span class="ne-text"></span></p></details>


## <font style="color:#DF2A3F;">执行计划中type的解释？</font>
**回答要点：6种情况**

<details class="lake-collapse"><summary id="u665cc9bd"><span class="ne-text">参考</span></summary><p id="u41b99d32" class="ne-p"><span class="ne-text">all：全表扫描；(主键索引中叶子节点)</span></p><p id="u5417af3b" class="ne-p"><span class="ne-text">index：全索引扫描；(主键索引中非叶子节点)<br /></span><span class="ne-text">range：范围扫描；</span></p><p id="u7102948c" class="ne-p"><span class="ne-text">ref：非唯一索引</span></p><p id="u7bd7ef86" class="ne-p"><span class="ne-text">eq_ref：唯一索引</span></p><p id="u4666536a" class="ne-p"><span class="ne-text">const：一般结果最多一条；意思是使用了 (id = 2之类的)主键or唯一索引与常数进行值比较；</span></p></details>


## <font style="color:#DF2A3F;">从数据页的角度看B+树？</font>
**回答要点：页存储方式+页结构、含义**

<details class="lake-collapse"><summary id="u38c4cdc1"><span class="ne-text">参考</span></summary><p id="u38a144f8" class="ne-p"><span class="ne-text">数据页：InnDB中，数据以页为单位存储，每个页默认大小16KB；</span></p><p id="u6ec9f9c0" class="ne-p"><span class="ne-text">数据页结构：7部分构成、每部分含义、FIle Header 以双链表形式存储；</span></p><p id="uf89fb11c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1725953942357-1f972e96-dd9a-47bf-9fde-f658c0093c32.png" width="964" id="ubf585112" class="ne-image"></p><p id="u492d39a1" class="ne-p"><span class="ne-text">页目录与记录之间关系结构：</span></p><p id="ub38899cc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1725954738941-02684411-29d7-4ca1-85ec-5867fe030d46.png" width="552" id="u15700e59" class="ne-image"></p><p id="u63c2a8ac" class="ne-p"><br></p><p id="ubf57bcdb" class="ne-p"><span class="ne-text">整个记录在B+树结构：</span></p><p id="u1e102eeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1725954466805-5f7eb8ce-6e48-4947-bd9d-9afa0ac59ced.png" width="711.7999877929688" id="ud971e67f" class="ne-image"></p><p id="u9e40983c" class="ne-p"><span class="ne-text"></span></p></details>


## **<font style="color:#DF2A3F;">为什么Mysql采用B+树索引？</font>**
**回答要点：通过各种数据结构比较+该种数据结构磁盘读写影响+增删改效率**

<details class="lake-collapse"><summary id="uc5279602"><span class="ne-text">参考</span></summary><p id="ud1a3a8aa" class="ne-p"><span class="ne-text">参考下表；</span></p><p id="ua688cd61" class="ne-p"><span class="ne-text">MySQL数据是磁盘化，所以当访问数据时，需要将索引和记录I/O到内存；磁盘读写速度慢，因此设计的数据结构要尽可能减少磁盘的读写；</span></p></details>
| 算法 | 查询复杂度 | 插入复杂度 | 缺点 | 解决的问题 |
| --- | --- | --- | --- | --- |
| **二分查找** | O(logn) | O(n) | 插入时需要频繁的移动 |  |
| **二分查找树** | O(logn) | O(logn)/O(n) | 极端情况下变为链表 | <font style="color:#DF2A3F;background-color:#FBDE28;">降低</font>**<font style="color:#DF2A3F;background-color:#FBDE28;">二分查找插入</font>**<font style="color:#DF2A3F;background-color:#FBDE28;">复杂度</font> |
| **自平衡二叉树** | O(logn) | O(logn) | 树过高，影响I/O；可能需要改变树结构； | <font style="color:#DF2A3F;background-color:#FBDE28;">解决极端情况变为</font>**<font style="color:#DF2A3F;background-color:#FBDE28;">链表</font>** |
| **B树** | O(logn) | O(logn) | 非叶子节点也存储记录；影响I/O；插入时可能改变树结构； | <font style="color:#DF2A3F;background-color:#FBDE28;">解决自平衡二叉树</font>**<font style="color:#DF2A3F;background-color:#FBDE28;">树高问题(一个节点存储多个记录)</font>**<font style="color:#DF2A3F;background-color:#FBDE28;">，降低I/O;</font> |
| **B+树** | O(logn) | O(logn) | | <font style="color:#DF2A3F;background-color:#FBDE28;">树高保持在3-4层；只有叶子节点存储数据；树结构改变概率变低</font> |




## <font style="color:#DF2A3F;">MySQL单表查询不超过2000W行，靠谱吗？</font>
**回答要点：宏观实验(2000W时会发生什么)+微观计算()**

<details class="lake-collapse"><summary id="u674a611d"><span class="ne-text">参考(这题目想说啥？？？)</span></summary><p id="u1695fe10" class="ne-p"><span class="ne-text">实验数据：1.当MySQL数据超过2000W时，查询时间长达10S+；2. 当主键使用自增ID，以1亿/s速度记录数据，用完需要5849年；</span></p><p id="ud91602d4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1726129025394-0f0a2068-2fcf-4b3e-8cbc-19ac23f3de6e.png" width="740" id="uede9e1e4" class="ne-image"></p><p id="u06e1f76e" class="ne-p"><span class="ne-text">微观计算：</span></p><p id="u1a43276c" class="ne-p"><span class="ne-text">页的存储中，只有三部分记录，大约15KB；</span></p><p id="u62609517" class="ne-p"><br></p><p id="ud0c63ed2" class="ne-p"><span class="ne-text"></span></p><p id="u2e752151" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1726129152797-8d780905-3ba1-434b-880a-d07d43c74b30.png" width="738.4" id="ua3ae1142" class="ne-image"></p><p id="udbe0c50e" class="ne-p"><span class="ne-text">Total=X</span><sup><span class="ne-text">(z-1) </span></sup><code class="ne-code"><span class="ne-text">*</span></code><span class="ne-text">Y;   x表示非叶子节点存储的索引条数；Y表示叶子节点存储的记录条数；Z表示B+树树高； </span></p><p id="ud2c82bdf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1726129066724-752297c0-08ef-4513-a15f-eb6b93b02bfa.png" width="729.6" id="u089635c2" class="ne-image"></p><p id="u4fb4c487" class="ne-p"><span class="ne-text">X：主键(8byte)+页号(4Byte)=12Byte； X=1024*15/12≈1280行；</span></p><p id="u1a8bf4e8" class="ne-p"><span class="ne-text">Y：假设一行记录1KB； Y=15行；</span></p><ul class="ne-ul"><li id="udd7720ab" data-lake-index-type="0"><span class="ne-text">假设 B+ 树是两层，那就是 z = 2， Total = （1280 ^1 ）*15 = 19200</span></li><li id="u85dda35f" data-lake-index-type="0"><span class="ne-text">假设 B+ 树是三层，那就是 z = 3， Total = （1280 ^2） *15 = 24576000 （约 2.45kw）</span></li></ul></details>
## <font style="color:#DF2A3F;">索引失效有哪些？</font>
**回答要点：索引数据结构特点+6种情况**

<details class="lake-collapse"><summary id="u5e39d8bc"><span class="ne-text">参考</span></summary><p id="ub9e9563b" class="ne-p"><span class="ne-text">索引数据结构：<br /></span><span class="ne-text">二级索引：叶子节点存储主键值，当需要完整记录时需要回表；<br /></span><span class="ne-text">主键索引：叶子节点存储完整记录；</span></p><p id="ub66d32b1" class="ne-p"><span class="ne-text">失效：</span></p><ol class="ne-ol"><li id="ue6b22390" data-lake-index-type="0"><span class="ne-text">使用模糊匹配：原因时不知道从哪个索引开始比较；</span></li></ol><p id="u5313d82e" class="ne-p" style="text-indent: 2em"><span class="ne-text">比如 ：like%XX%，%XX；</span></p><ol start="2" class="ne-ol"><li id="u1e236d62" data-lake-index-type="0"><span class="ne-text">对使用函数的索引：索引字段没有该函数的处理结果</span></li></ol><p id="u96682efd" class="ne-p" style="text-indent: 2em"><span class="ne-text">比如：selsect* from t_user where length(name)=6； 索引中并没有字段存储长度信息；</span></p><ol start="3" class="ne-ol"><li id="u8c54f45d" data-lake-index-type="0"><span class="ne-text">对索引进行了表达式计算：表达式相当于函数，没有记录表达式信息；</span></li></ol><p id="u95d01e23" class="ne-p" style="text-indent: 2em"><span class="ne-text">比如： ...where id+1 =10；</span><span class="ne-text" style="color: #DF2A3F"> 特殊：...where id = 10-1；</span></p><ol start="4" class="ne-ol"><li id="u60360506" data-lake-index-type="0"><span class="ne-text">对索引进行隐式类型转换：MySQL会自动将字符串转为数字(如果有必要)；</span></li></ol><p id="ue5a78cae" class="ne-p" style="text-indent: 2em"><span class="ne-text">比如： ...where phone =1300001；//建表时phone字段为字符串；</span></p><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u57dc1a28" data-lake-index-type="0"><span class="ne-text">(索引)字符串 = 值(数字)；隐式转换会调用函数将索引字段转换为数字类型；因此成了情况2；</span></li><li id="u081089d4" data-lake-index-type="0"><span class="ne-text" style="color: #DF2A3F">(索引)数字= 值(字符串 )；隐式转换调用函数将字符串变为数字；但索引为使用函数，所以未失效；(特例)</span></li></ul></ul><ol start="5" class="ne-ol"><li id="u57311ef4" data-lake-index-type="0"><span class="ne-text">联合索引非最左匹配：没按照联合索引字段进行匹配；</span></li><li id="u976bed69" data-lake-index-type="0"><span class="ne-text">where子句种的or：为了满足or条件，需进行全表扫描；</span></li></ol><p id="u7ad2eb41" class="ne-p" style="text-indent: 2em"><span class="ne-text">比如：select*from  t_user where id(索引字段)=1 or age(非索引字段) =18;为满足后者只能进行全表扫描，索引失效；</span></p><p id="u1d482ac9" class="ne-p"><br></p><p id="ue817eab5" class="ne-p" style="text-indent: 2em"><span class="ne-text"></span></p></details>
## <font style="color:#DF2A3F;">Mysql使用%XX%，索引一定会失效吗？(失效是指全表扫描)</font>
**回答要点：特例：全索引扫描**

<details class="lake-collapse"><summary id="u098bd53b"><span class="ne-text">参考</span></summary><p id="u747f95e4" class="ne-p"><span class="ne-text">如下表格</span></p></details>
<font style="background-color:#FBDE28;">在下表种那些情况索引失效？</font>

表格1：该表有**多个**字段：name为索引，id为自增主键索引，其余为非索引字段；  
表格2：该表有**2个**字段：name为索引，id为自增主键索引

分别执行如下语句：select*from t_user where name like.... [表格]？那些会失效？



| 表格/语句条件(是否失效) | "xxx" | "xx%" | "%xx" | "%xx%" |
| --- | --- | --- | --- | --- |
| 表格1 | X(range) | X(range) | √(ALL) | √(ALL) |
| 表格2(联合索引) | X(range) | X(range) | X(index) | X(index) |


表中：(x表示未失效，√表示索引失效)。range表示范围扫描，index表时全索引扫描；ALL表示全表扫描；

<font style="background-color:#FBDE28;">补充：回表不算索引失效；</font>

<font style="background-color:#FBDE28;">为什么表2中走二级索引的全索引扫描而不是聚簇索引的全表扫描？因为二级索引的记录信息更少，提高查询效率，节约时间；</font>

<font style="background-color:#FBDE28;"></font>

## <font style="color:#DF2A3F;">count(*)与count(1)有什么区别？哪个表的性能好？</font>
**回答要点：解释* = 0  + count函数意思；**

<details class="lake-collapse"><summary id="ub14a7858"><span class="ne-text">参考：</span><span class="ne-text" style="color: #DF2A3F">对于执行过还是比较模糊：具体走什么表，怎么计数？</span></summary><p id="u79cb2bb5" class="ne-p"><span class="ne-text">性能：count(*)=count(1)&gt;count(主键字段)&gt;count(字段)；</span></p><p id="u0002c8be" class="ne-p"><span class="ne-text">count()：记录指定参数不为NULL的记录有多少个？</span></p><p id="u0207b110" class="ne-p"><span class="ne-text">count(1/*)：1/0是非空参数，记录表中的记录，包括空字段；</span></p><p id="u7610ecb8" class="ne-p"><span class="ne-text"></span></p><p id="u229bd142" class="ne-p"><span class="ne-text">count(1/0)的执行过程？</span></p><p id="u0210289e" class="ne-p"><span class="ne-text">没有二级索引时：</span></p><ol class="ne-ol"><li id="u4ce33a21" data-lake-index-type="0"><span class="ne-text">遍历聚簇索引，读取记录返回给Server层；</span></li><li id="u4c4f0d4d" data-lake-index-type="0"><span class="ne-text">有一条记录就count+1；</span></li></ol><p id="u749c4b1b" class="ne-p"><span class="ne-text"></span></p><p id="ueabfbb2a" class="ne-p"><span class="ne-text"></span></p><p id="uf2aa4a88" class="ne-p"><span class="ne-text">有二级索引时：</span></p><ol class="ne-ol"><li id="ub1de22a0" data-lake-index-type="0"><span class="ne-text">遍历二级索引；读取记录返回给Server层；</span></li><li id="u1e41e369" data-lake-index-type="0"><span class="ne-text">count+1； </span></li></ol><p id="u92da05b0" class="ne-p"><span class="ne-text"></span></p><p id="u6e6ff262" class="ne-p"><span class="ne-text">count(主键字段)执行过程？</span></p><ol class="ne-ol"><li id="ucc6ff20c" data-lake-index-type="0"><span class="ne-text">遍历聚簇索引，读取记录返回给Server层；</span></li><li id="u39c4e79a" data-lake-index-type="0"><span class="ne-text">判断主键是否为空；</span></li><li id="ue98e5a9d" data-lake-index-type="0"><span class="ne-text">不为空就count+1；</span></li></ol><p id="u1523e929" class="ne-p"><span class="ne-text"></span></p><p id="u4bc81b0d" class="ne-p"><span class="ne-text">count(字段)执行过程？</span></p><ol class="ne-ol"><li id="u74e925a7" data-lake-index-type="0"><span class="ne-text">全表扫描读取指定字段的值</span></li><li id="u2794c594" data-lake-index-type="0"><span class="ne-text"> 检查该值是否为NULL</span></li><li id="uf293ea9e" data-lake-index-type="0"><span class="ne-text"> 如果不是NULL，计数器count加1</span></li></ol><p id="u982ef8e1" class="ne-p"><span class="ne-text"></span></p><p id="uc9940ee3" class="ne-p"><span class="ne-text">为什么二级索引扫描速度&gt;主键&gt;全表？</span></p><p id="u7525feb7" class="ne-p"><span class="ne-text">因为每条记录大小不同，二级索引更小；</span></p></details>
## <font style="color:#DF2A3F;">为什么要通过遍历方式来计数？</font>
**回答要点：事务+MVCC**

<details class="lake-collapse"><summary id="ubf94b100"><span class="ne-text">参考</span></summary><p id="u80644e82" class="ne-p"><span class="ne-text">InnDB支持事务引擎，要保持事务环境下的一致性；</span></p><p id="u486a434c" class="ne-p"><span class="ne-text">遍历可以确保只计算符合当前事务视图的记录数；</span></p></details>
## <font style="color:#DF2A3F;">如何优化count(*)？</font>
**回答要点：额外建表+ explain**

<details class="lake-collapse"><summary id="ue805d0b1"><span class="ne-text">参考</span></summary><p id="u13b2aa02" class="ne-p"><span class="ne-text">额外创建一张表来记录；</span></p><p id="ufe93ec02" class="ne-p"><span class="ne-text">执行explain命令：</span></p><p id="ub6390d5f" class="ne-p"><span class="ne-text">explain select*from t-user；</span></p></details>


## <font style="color:#DF2A3F;">事务的隔离具体是怎么实现的？</font>
**回答要点**

<details class="lake-collapse"><summary id="u52e3871d"><span class="ne-text">参考</span></summary><p id="u575ccab0" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">什么是事务？</span></p><p id="uaf0d8859" class="ne-p"><span class="ne-text" style="font-size: 16px">事务是对数据库的一系列操作；</span></p><p id="u898aba24" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">事务特性？</span></p><p id="u8c5aa061" class="ne-p"><span class="ne-text" style="font-size: 16px">ACID；</span></p><p id="u0b905f72" class="ne-p"><span class="ne-text" style="font-size: 16px">原子性：事务中的所有操作要么全部完成，要么全部没完成；</span></p><p id="u269066b9" class="ne-p"><span class="ne-text" style="font-size: 16px">一致性：事务操作前后，数据库满足完整性约束；<br /></span><span class="ne-text" style="font-size: 16px">隔离性：并行事务发生时，每个事务都由一个完整的事务空间；<br /></span><span class="ne-text" style="font-size: 16px">持久性：数据一旦被修改，则永久生效；</span></p><p id="uc086d90e" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px"><br /></span><span class="ne-text" style="color: #DF2A3F; font-size: 19px">事务并行引发的问题？</span></p><p id="ub9a4c1a9" class="ne-p"><span class="ne-text" style="font-size: 16px">脏读：一个事务读到了另一个</span><strong><span class="ne-text" style="font-size: 16px">未提交事务</span></strong><span class="ne-text" style="font-size: 16px">修改过的数据；<br /></span><span class="ne-text" style="font-size: 16px">不可重复读：在</span><strong><span class="ne-text" style="font-size: 16px">一个事务</span></strong><span class="ne-text" style="font-size: 16px">中多次</span><strong><span class="ne-text" style="font-size: 16px">读取同一个数据</span></strong><span class="ne-text" style="font-size: 16px">，前后两次读到的数</span><strong><span class="ne-text" style="font-size: 16px">据不一致</span></strong><span class="ne-text" style="font-size: 16px">；<br /></span><span class="ne-text" style="font-size: 16px">幻读：在一个事务中多次查询某个符合条件的记录数量，记录数量不一样；</span></p><p id="ud4391eb8" class="ne-p"><span class="ne-text" style="font-size: 16px">严重性从大到小排序：脏读&gt;不可重复读&gt;幻读</span></p><p id="ude77c117" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p><p id="u0c279f94" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">事务的隔离等级？</span></p><p id="u4ad53940" class="ne-p"><span class="ne-text" style="font-size: 16px">读未提交：指一个事务</span><strong><span class="ne-text" style="font-size: 16px">没有提交</span></strong><span class="ne-text" style="font-size: 16px">，它的变更就</span><strong><span class="ne-text" style="font-size: 16px">被其他事务看到</span></strong><span class="ne-text" style="font-size: 16px">；<br /></span><span class="ne-text" style="font-size: 16px">独提交：一个事务</span><strong><span class="ne-text" style="font-size: 16px">提交之后</span></strong><span class="ne-text" style="font-size: 16px">，它的变更才能</span><strong><span class="ne-text" style="font-size: 16px">被其他事务看到</span></strong><span class="ne-text" style="font-size: 16px">；<br /></span><span class="ne-text" style="font-size: 16px">可重复读：一个事务执行过程中</span><strong><span class="ne-text" style="font-size: 16px">多次看到的数据</span></strong><span class="ne-text" style="font-size: 16px">，跟事务</span><strong><span class="ne-text" style="font-size: 16px">启动时</span></strong><span class="ne-text" style="font-size: 16px">看到的 </span><strong><span class="ne-text" style="font-size: 16px">数据一致</span></strong><span class="ne-text" style="font-size: 16px">；<br /></span><span class="ne-text" style="font-size: 16px">串行化：对记录加上</span><strong><span class="ne-text" style="font-size: 16px">读写锁</span></strong><span class="ne-text" style="font-size: 16px">，当多个事务读写操作发生，</span><strong><span class="ne-text" style="font-size: 16px">后者必须等前者</span></strong><span class="ne-text" style="font-size: 16px">完成，才能继续执行；</span></p><p id="u2cd84769" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p><p id="uddbafb76" class="ne-p"><span class="ne-text" style="font-size: 16px">隔离强度高低：串行化&gt;可重复读&gt;读已提交&gt;读未提交</span></p><p id="u26e27fa0" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px"><br /></span><span class="ne-text" style="color: #DF2A3F; font-size: 19px">不同隔离等级下会出现的现象？</span></p><p id="u6e4c4cc2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1726283603835-c8f3edff-546d-43d6-a11c-eedddf52c466.png" width="776.8" id="u8e6db247" class="ne-image"></p><p id="u41b512c5" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">案例分析？</span></p><p id="u18150c6b" class="ne-p"><span class="ne-text" style="font-size: 16px">下面两个事务在不同隔离等级下读取的信息：</span></p><p id="u1d1d893a" class="ne-p"><span class="ne-text" style="font-size: 16px">读未提交：V1=V2=V3=200；</span></p><p id="ud06af6e1" class="ne-p"><span class="ne-text" style="font-size: 16px">读提交：V1=100，V2=V3=200；</span></p><p id="u3808c712" class="ne-p"><span class="ne-text" style="font-size: 16px">可重复读：V1=V2=100；V3=200；</span></p><p id="u22cc2110" class="ne-p"><span class="ne-text" style="font-size: 16px">串行化：</span><span class="ne-text" style="color: #DF2A3F; text-decoration: line-through; font-size: 16px">V1=V2=V3=200；</span><span class="ne-text" style="font-size: 16px">  V1=V2=100；V3=200；//此前事务A读到为100，添加读锁，事务B修改时发现事务A加了读锁，只有到事务A结束时，事务B才能进行修改操作；</span></p><p id="u3dfaa405" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1726283780754-e92e8eec-62e4-450d-aba3-97d6bb7ee2d6.png" width="457.6" id="uffeee6a1" class="ne-image"></p><p id="ufd1bc793" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">四种隔离等级具体是如何实现的？</span></p><p id="ue63711b5" class="ne-p"><span class="ne-text" style="font-size: 16px">读未提交：不加任何锁</span></p><p id="u09775277" class="ne-p"><span class="ne-text" style="font-size: 16px">读已提交：I</span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">nnoDB会在每次普通SELECT操作前生成一个新的Read View，保证其他事务的修改也能看到。</span><span class="ne-text" style="font-size: 16px"><br /></span><span class="ne-text" style="font-size: 16px">可重复读：在事务开始时生成一个Read View；</span></p><p id="u513dd228" class="ne-p"><span class="ne-text" style="font-size: 16px">串行化：加读写锁；</span></p><p id="u108088b1" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px"></span></p><p id="u39846e77" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">Rea</span><span class="ne-text" style="color: #DF2A3F; font-size: 16px">d View在MVCC下是如何工作的？</span></p><p id="ub4c9aa6b" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: #1DC0C9; font-size: 16px">MVCC 概述</span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">:是InnoDB 用来实现事务隔离级别的一种机制。它的核心思想是，当有多个事务并发执行时，每个事务看到的数据版本可能是不同的。</span></p><p id="u0aa1bc38" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: #1DC0C9; font-size: 16px">Read View 的作用: </span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">可以理解为事务在某个时间点给数据库打的一个快照。它决定了事务能看到哪些数据版本。</span></p><p id="ufc0a2682" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: #1DC0C9; font-size: 16px">Read View 的组成:</span></p><ul class="ne-ul"><li id="u67a24db7" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">trx_ids: 当前系统中活跃（未提交）的事务 ID 列表。</span></li><li id="u0176d57d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">low_limit_id: 目前出现过的最大事务 ID+1。</span></li><li id="u7e0e7670" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">up_limit_id: trx_ids 列表中最小的事务 ID。</span></li><li id="u708680cc" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">creator_trx_id: 创建该 Read View 的事务 ID。</span></li></ul><p id="u92262f41" class="ne-p"><br></p><p id="u3b54581c" class="ne-p"><span class="ne-text" style="background-color: #1DC0C9; font-size: 16px">工作流程：</span></p><ol class="ne-ol"><li id="u7ef35d4f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">当事务启动时，InnoDB 会为该事务创建一个 Read View。</span></li><li id="u33182aa7" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">. 每行数据都有隐藏字段：</span></li></ol><ul class="ne-ul"><li id="u1b6b5f5e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">DB_TRX_ID: 最后一次修改该行的事务 ID</span></li><li id="uba8b2b58" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">DB_ROLL_PTR: 回滚指针，指向该行的上一个版本</span></li><li id="u1114bf30" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">DB_ROW_ID: 行 ID</span></li></ul><ol start="3" class="ne-ol"><li id="ud122bbad" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">当事务要读取一行数据时，InnoDB 会拿着这个 Read View 去判断当前行的可见性：</span></li></ol><ul class="ne-ul"><li id="u865847fc" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">如果 DB_TRX_ID &lt; up_limit_id，说明这个版本是已经提交的事务生成的，可以被当前事务看到。</span></li><li id="u509efd98" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">如果 DB_TRX_ID &gt;= low_limit_id，说明这个版本是由将来启动的事务生成的，不可见。</span></li><li id="ucacbeb64" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">如果 up_limit_id &lt;= DB_TRX_ID &lt; low_limit_id，需要再判断 DB_TRX_ID 是否在 trx_ids 列表中。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u050232e1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">如果在，说明这个版本是由还未提交的事务生成的，不可见。</span></li><li id="u86755857" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">如果不在，说明这个版本是已经提交的事务生成的，可见。</span></li></ul></ul><ol start="4" class="ne-ol"><li id="ub8e6c4df" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">如果当前版本不可见，InnoDB 会顺着 DB_ROLL_PTR 找到该行的上一个版本，继续判断可见性，直到找到可见的版本或者返回空。</span></li></ol><p id="udac65c85" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">可重复读隔离的等级是如何工作的？</span></p><ul class="ne-ul"><li id="ueef345be" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">在 REPEATABLE READ 级别，只在事务开始时生成一个 Read View，整个事务期间都使用这个 Read View。</span></li></ul><p id="ufed85db5" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px"><br /></span><span class="ne-text" style="color: #DF2A3F; font-size: 19px">读已提交隔离等级是如何工作的？</span></p><ul class="ne-ul"><li id="u1fe443f6" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">在 READ COMMITTED 级别，每次读取数据前都会生成一个新的 Read View。</span></li></ul><p id="ucf1f56ce" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px"></span></p><p id="u3b227526" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px"></span></p><p id="u04875c09" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">为什么可重复读隔离等级会出现幻读而不会出现不可重复读？</span></p><ol class="ne-ol"><li id="u77a9dbeb" data-lake-index-type="0"><span class="ne-text">不可重复读概念：一个事务中，多次读取的</span><span class="ne-text" style="background-color: #FBDE28">同一数据</span><span class="ne-text">，</span><span class="ne-text" style="background-color: #FBDE28">结果</span><span class="ne-text">不一致； 一般是由于</span><strong><span class="ne-text" style="background-color: #FBDE28">其他事务修改了数据</span></strong><span class="ne-text">；</span></li><li id="u8ed1a81e" data-lake-index-type="0"><span class="ne-text">幻读概念：一个事务中，多次读取</span><span class="ne-text" style="background-color: #FBDE28">同一查询</span><span class="ne-text">，</span><span class="ne-text" style="background-color: #FBDE28">结果集</span><span class="ne-text">不一致；一般是由于</span><strong><span class="ne-text" style="background-color: #FBDE28">其他事务插入或删除</span></strong><strong><span class="ne-text">符合条件的行</span></strong><span class="ne-text">；</span></li><li id="u5f0e8ca4" data-lake-index-type="0"><span class="ne-text">可重复读隔离等级概念：可重复读会在事务启动时创建一个</span><span class="ne-text" style="background-color: #FBDE28">一致性快照</span><span class="ne-text">。一致性快照</span><span class="ne-text" style="background-color: #FBDE28">防止</span><span class="ne-text">当前事务中</span><span class="ne-text" style="background-color: #FBDE28">数据被其他事务修改</span><span class="ne-text">，以及</span><span class="ne-text" style="background-color: #FBDE28">记录被其他事务删除</span><span class="ne-text">；但是</span><span class="ne-text" style="background-color: #FBDE28">无法防止新记录的插入(幻读的产生)</span><span class="ne-text">；</span></li><li id="u7e10d53a" data-lake-index-type="0"><span class="ne-text">即幻读产生是因为可重复读无法阻止新数据插入，不可重复读不发生是因为一致性快照保证了已有数据的稳定性；</span></li></ol><p id="u4718c426" class="ne-p"><span class="ne-text"></span></p><p id="uf6ba8692" class="ne-p"><span class="ne-text" style="color: #DF2A3F; font-size: 19px">同一个事务中修改了数据或添加/删除记录，一致性快照还生效吗？</span></p><p id="u21d0ebd3" class="ne-p"><span class="ne-text">一致性快照是针对不同事务间的；同一事物的修改记录/删除记录/添加记录是能被看到的。</span></p><p id="ue33ad2a3" class="ne-p"><br></p></details>
## <font style="color:#DF2A3F;">MySQL 可重复读隔离级别，完全解决幻读了吗？</font>
**回答要点：**

<details class="lake-collapse"><summary id="u461d7cff"><span class="ne-text">参考：</span></summary><ol class="ne-ol"><li id="uf208082e" data-lake-index-type="0"><span class="ne-text">快照读如何避免幻读？</span></li></ol><p id="ufa22b91e" class="ne-p"><span class="ne-text">在第一次执行完select操作时创建Read View；</span></p><p id="uc724e0c6" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247)">具体流程<br /></span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247)"> 	a. 事务开始（如BEGIN或START TRANSACTION）。<br /></span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247)">	b. 执行第一个SELECT操作（快照读）。<br /></span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247)">	c. 此时，InnoDB创建ReadView：</span></p><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u06835249" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247)">记录当前活跃的事务ID列表。</span></li><li id="u59fd0f0a" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247)">设置事务可见性边界。</span></li></ul></ul><p id="u4d36d6a0" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247)"> 	d. 后续的所有快照读都使用这个ReadView。</span></p><ol start="2" class="ne-ol"><li id="u7c31e7d0" data-lake-index-type="0"><span class="ne-text">当前读是如何避免幻读？</span></li></ol><p id="u1c89936c" class="ne-p"><span class="ne-text">在非select操作时添加间隙锁；</span></p><p id="u5f647277" class="ne-p"><span class="ne-text">       a.  具体操作：会添加如下语句：</span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">SELECT ... FOR UPDATE </span></p><p id="u28a72995" class="ne-p" style="text-indent: 2em"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">解释：</span></p><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u929bf9a4" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">SELECT ... FOR UPDATE 不执行任何修改操作，它只是锁定行。</span></li><li id="u09e0267e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">锁定后，可以执行任何类型的 DML 操作（INSERT、UPDATE、DELETE）。</span></li><li id="uaceaa3f7" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">锁会持续到事务结束（COMMIT 或 ROLLBACK）。</span></li></ul></ul><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="u8401548d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用方式：</span></li></ol></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u29e7fcd7" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">对于要读取的行，InnoDB会先获取其锁。</span></li><li id="ue2db7e69" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">如果行被其他事务修改且未提交，当前事务会等待直到锁释放。</span></li><li id="ua4230a60" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">获取锁后，读取最新的数据版本。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="u3edc6142" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="font-size: 16px">可重复读真的可以避免吗？</span></li></ol><p id="u5b4ee9d7" class="ne-p"><span class="ne-text" style="font-size: 16px">不能。</span></p><p id="u3966a9d7" class="ne-p"><span class="ne-text" style="font-size: 16px">情况一：</span></p><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uc3cd6f91" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">第一次执行select时事务是快照读，读取后未发现有id=5的记录。</span></li><li id="ue1afab02" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">接着执行update操作，会获取id=5并修改了记录；</span></li><li id="uf9771bf6" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">此时接着执行select操作，由于本事务操作可见，导致最终读取了id=5的记录。</span></li></ol></ol><p id="uc2cfffe0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/22186123/1726217574404-f2bc33d3-91a2-4994-b4fb-715bdcb294ff.png" width="751.2" id="ub92537d6" class="ne-image"></p><p id="u3be4f680" class="ne-p"><span class="ne-text">情况二：</span></p><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua9595051" data-lake-index-type="0"><span class="ne-text">T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</span></li><li id="u99a0ca01" data-lake-index-type="0"><span class="ne-text">T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</span></li><li id="uca9bf706" data-lake-index-type="0"><span class="ne-text">T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</span></li></ol></ol><p id="u04f6625f" class="ne-p"><span class="ne-text" style="color: #DF2A3F">要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，</span><span class="ne-text" style="color: #DF2A3F; background-color: #FBDE28">马上执行 select ... for update 这类当前读的语句</span><span class="ne-text" style="color: #DF2A3F">，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</span></p></details>
<font style="color:#117CEE;background-color:rgb(247, 247, 247);"></font>

## <font style="color:#DF2A3F;background-color:rgb(247, 247, 247);">MySQL中有哪些锁？</font>
回答要点：全局锁＋表级锁(4)＋行级锁(4)

<details class="lake-collapse"><summary id="ud636e1bb"><span class="ne-text">参考：</span></summary><p id="u9ff96872" class="ne-p"><span class="ne-text">全局锁：使得整个数据库处于只读状态。</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">加上全局锁，意味着整个数据库都是只读状态。</span></p><pre data-language="sql" id="UbzYK" class="ne-codeblock language-sql"><code>flush tables with read lock</code></pre><pre data-language="sql" id="JOu6X" class="ne-codeblock language-sql"><code>unlock tables</code></pre><p id="u489dd7af" class="ne-p" style="text-indent: 2em; margin-left: 2em"><span class="ne-text">补充：会话终止，全局锁也会释放；<br /></span><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">      会话：会话是从客户端连接到MySQL服务器开始，到客户端断开连接为止的这段时间。</span></p><p id="u8d7b8be4" class="ne-p" style="text-indent: 2em; margin-left: 2em"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px"></span></p><p id="u082ac04c" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); background-color: rgb(247, 247, 247); font-size: 16px">表级锁：</span></p><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u5b25b125" data-lake-index-type="0"><span class="ne-text">表锁</span></li></ul></ul><pre data-language="sql" id="A8QX6" class="ne-codeblock language-sql"><code>//添加
//表级别的共享锁，也就是读锁
lock tables t_student read;
//表级别的独占锁，也就是写锁；
lock tables t_stuent write;

//释放
unlock tables</code></pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u2e94ca0f" data-lake-index-type="0"><span class="ne-text">元素据锁</span></li></ul></ul><pre data-language="bash" id="YjAdZ" class="ne-codeblock language-bash"><code>概念：用来保护数据库对象定义（即元数据）的锁。

作用：
防止对象被并发修改。
确保正在被查询的表结构不会被修改。

执行时机：
执行语句时，自动添加

例子：
事务A开始一个长时间运行的查询
事务B尝试修改表结构

-- 事务A
START TRANSACTION;
SELECT * FROM large_table WHERE complex_condition;
-- 此查询需要很长时间

-- 事务B
ALTER TABLE large_table ADD COLUMN new_column INT;
-- 这个ALTER语句会被阻塞，直到事务A完成N email VARCHAR(255);
</code></pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u3e66a083" data-lake-index-type="0"><span class="ne-text">意向锁：</span></li></ul></ul><pre data-language="bash" id="zrIZb" class="ne-codeblock language-bash"><code>概念：
意向锁是一种表级锁，用来表示事务稍后要进行哪种类型的锁定（共享或排他）。

类型：
意向共享锁（IS）：表示事务想要获取表中某些行的共享锁。
意向排他锁（IX）：表示事务想要获取表中某些行的排他锁。

作用：
允许行锁和表锁共存
提高加锁效率，避免InnoDB逐行检查是否有锁冲突

示例：
-- 这个查询会在表级别设置IS锁，在行级别设置S锁
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;
-- 这个查询会在表级别设置IX锁，在行级别设置X锁
SELECT * FROM users WHERE id = 1 FOR UPDATE;
------------------------------------------------------------------
事务A获取行级共享锁
事务B尝试获取表级写锁
-- 事务A
START TRANSACTION;
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;
-- 这会设置IS锁和行级S锁

-- 事务B
LOCK TABLES users WRITE;
-- 这个操作会被阻塞，因为与IS锁冲突</code></pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ue3fd526b" data-lake-index-type="0"><span class="ne-text">AUTO-INC锁：</span></li></ul></ul><pre data-language="bash" id="B5drm" class="ne-codeblock language-bash"><code>概念：
AUTO-INC锁是一种特殊的表级锁，用于管理自增列（AUTO_INCREMENT）的值的分配。

作用：
确保在并发插入时自增值的唯一性和连续性。
控制自增值的生成方式，影响并发插入的性能。

示例：
-- 创建一个带有自增列的表
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_date DATE
);

-- 插入数据时会自动获取AUTO-INC锁
INSERT INTO orders (order_date) VALUES (CURDATE());
-------------------------------------------------------------------
设置不同的innodb_autoinc_lock_mode
执行批量插入操作
观察性能差异

-- 设置传统的锁定模式
SET @@global.innodb_autoinc_lock_mode = 0;

-- 执行批量插入
INSERT INTO orders (order_date) VALUES (CURDATE()), (CURDATE()), (CURDATE());
-- 在这种模式下，每个INSERT语句都会持有AUTO-INC锁直到语句结束

-- 设置连续模式
SET @@global.innodb_autoinc_lock_mode = 1;

-- 再次执行批量插入
INSERT INTO orders (order_date) VALUES (CURDATE()), (CURDATE()), (CURDATE());
-- 在这种模式下，对于可以预先确定插入行数的语句，会采用更轻量级的锁定机制
</code></pre><p id="ude5f94a9" class="ne-p"><span class="ne-text">行级锁：</span></p><ul class="ne-ul"><li id="ucc375a28" data-lake-index-type="0" style="text-align: left"><a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#record-lock" data-href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#record-lock" target="_blank" class="ne-link"><span class="ne-text" style="color: rgb(44, 62, 80)">Record Lock</span></a><span class="ne-text" style="color: rgb(44, 62, 80)">：</span></li><li id="uff86a36d" data-lake-index-type="0" style="text-align: left"><a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#gap-lock" data-href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#gap-lock" target="_blank" class="ne-link"><span class="ne-text" style="color: rgb(44, 62, 80)">Gap Lock</span></a><span class="ne-text" style="color: rgb(44, 62, 80)">:</span></li><li id="u48dc6ec9" data-lake-index-type="0" style="text-align: left"><a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#next-key-lock" data-href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#next-key-lock" target="_blank" class="ne-link"><span class="ne-text" style="color: rgb(44, 62, 80)">Next-Key Lock</span></a><span class="ne-text" style="color: rgb(44, 62, 80)">：</span></li><li id="uea2bd94f" data-lake-index-type="0" style="text-align: left"><a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81" data-href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81" target="_blank" class="ne-link"><span class="ne-text" style="color: rgb(44, 62, 80)">插入意向锁</span></a><span class="ne-text" style="color: rgb(44, 62, 80)">：</span></li></ul><p id="ufb045d61" class="ne-p"><span class="ne-text">Record Lock (记录锁)<br /></span><span class="ne-text">概念:<br /></span><span class="ne-text">Record Lock是最基本的行级锁,它锁定索引记录。<br /></span><span class="ne-text">作用范围:<br /></span><span class="ne-text">只锁定索引记录本身。<br /></span><span class="ne-text">工作流程:</span></p><ol class="ne-ol"><li id="u762d3c6f" data-lake-index-type="0"><span class="ne-text">当事务需要修改或删除一行数据时,会先获取该行的Record Lock。<br /></span><span class="ne-text">锁住该行,防止其他事务修改或删除。<br /></span><span class="ne-text">事务完成后释放锁。<br /></span><span class="ne-text">例子:<br /></span><span class="ne-text">Gap Lock (间隙锁)<br /></span><span class="ne-text">概念:<br /></span><span class="ne-text">Gap Lock锁定索引记录之间的间隙。<br /></span><span class="ne-text">作用范围:<br /></span><span class="ne-text">锁定一个范围,但不包括记录本身。<br /></span><span class="ne-text">工作流程:<br /></span><span class="ne-text">当使用范围条件而不是相等条件检索数据时,InnoDB会使用Gap Lock。<br /></span><span class="ne-text">锁住检索条件范围内的间隙,防止其他事务在间隙中插入数据。</span></li><li id="u89aee4e2" data-lake-index-type="0"><span class="ne-text">事务完成后释放锁。<br /></span><span class="ne-text">例子:<br /></span><span class="ne-text">Next-Key Lock<br /></span><span class="ne-text">概念:<br /></span><span class="ne-text">Next-Key Lock是Record Lock和Gap Lock的结合。<br /></span><span class="ne-text">作用范围:<br /></span><span class="ne-text">锁定索引记录本身以及索引记录之前的间隙。<br /></span><span class="ne-text">工作流程:<br /></span><span class="ne-text">当InnoDB扫描索引记录时,会使用Next-Key Lock。<br /></span><span class="ne-text">锁住记录本身和记录前的间隙。<br /></span><span class="ne-text">防止幻读问题。<br /></span><span class="ne-text">例子:</span></li><li id="ua6cefb4b" data-lake-index-type="0"><span class="ne-text">插入意向锁 (Insert Intention Lock)<br /></span><span class="ne-text">概念:<br /></span><span class="ne-text">插入意向锁是一种特殊的Gap Lock,用于提高并发插入的效率。<br /></span><span class="ne-text">作用范围:<br /></span><span class="ne-text">只在插入操作时使用,锁定待插入的间隙。<br /></span><span class="ne-text">工作流程:<br /></span><span class="ne-text">当事务准备向间隙中插入记录时,先获取插入意向锁。<br /></span><span class="ne-text">如果多个事务要在同一个间隙的不同位置插入,它们不会互相阻塞。<br /></span><span class="ne-text">只有当另一个事务持有冲突的Gap Lock时,插入操作才会被阻塞。<br /></span><span class="ne-text">例子:<br /></span><span class="ne-text">总结:</span></li><li id="u3db232d4" data-lake-index-type="0"><span class="ne-text">Record Lock用于锁定单个记录。<br /></span><span class="ne-text">Gap Lock用于锁定记录之间的间隙。</span></li><li id="ue02a91e6" data-lake-index-type="0"><span class="ne-text">Next-Key Lock结合了Record Lock和Gap Lock,用于防止幻读。<br /></span><span class="ne-text">插入意向锁是一种特殊的Gap Lock,用于提高并发插入效率。<br /></span><span class="ne-text">这些锁机制共同工作,以确保在事务处理过程中的数据一致性和隔离性。理解这些锁的工作方式对于优化数据库性能和解决并发问题至关重要。</span></li></ol><p id="uf80b94c7" class="ne-p"><br></p></details>
<font style="background-color:rgb(247, 247, 247);">  
</font>

<font style="color:#117CEE;background-color:rgb(247, 247, 247);"></font>

<font style="color:#117CEE;background-color:rgb(247, 247, 247);">问题的产生通常源于对概念理解的不全面或不够深入。</font>

